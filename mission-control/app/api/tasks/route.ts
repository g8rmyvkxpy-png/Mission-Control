import { NextResponse } from 'next/server';

// Agent definitions
const AGENTS = [
  { id: 'atlas', name: 'Atlas', specialty: 'Lead Generation' },
  { id: 'pulse', name: 'Pulse', specialty: 'Prospecting' },
  { id: 'hunter', name: 'Hunter', specialty: 'Calling' },
  { id: 'phoenix', name: 'Phoenix', specialty: 'Conversion' },
  { id: 'scout', name: 'Scout', specialty: 'Analysis' },
  { id: 'radar', name: 'Radar', specialty: 'SEO' },
  { id: 'compass', name: 'Compass', specialty: 'Monitoring' },
  { id: 'trends', name: 'Trends', specialty: 'Trends' },
  { id: 'bond', name: 'Bond', specialty: 'Churn' },
  { id: 'mend', name: 'Mend', specialty: 'Resolution' },
  { id: 'grow', name: 'Grow', specialty: 'Upsell' },
  { id: 'byte', name: 'Byte', specialty: 'Build' },
  { id: 'pixel', name: 'Pixel', specialty: 'UI' },
  { id: 'server', name: 'Server', specialty: 'APIs' },
  { id: 'auto', name: 'Auto', specialty: 'Automation' },
  { id: 'ink', name: 'Ink', specialty: 'Blogs' },
  { id: 'blaze', name: 'Blaze', specialty: 'Twitter' },
  { id: 'cinema', name: 'Cinema', specialty: 'Video' },
  { id: 'draft', name: 'Draft', specialty: 'Newsletters' },
];

// Task interface
interface Task {
  id: string;
  title: string;
  description: string;
  assignedTo?: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  priority: 'low' | 'medium' | 'high';
  createdAt: number;
  updatedAt: number;
  completedAt?: number;
  result?: any;
  error?: string;
  metadata?: Record<string, any>;
}

// In-memory task queue
let tasks: Task[] = [];
const priorityOrder = { high: 0, medium: 1, low: 2 };

// === TOOL IMPLEMENTATIONS ===

// Tavily Search API
async function searchWeb(query: string, maxResults = 5) {
  const TAVILY_API_KEY = process.env.TAVILY_API_KEY || process.env.NEXT_PUBLIC_TAVILY_API_KEY;
  
  // Mock mode when no API key
  if (!TAVILY_API_KEY) {
    return {
      success: true,
      mock: true,
      results: [
        { title: `Result for: ${query}`, url: 'https://example.com/1', content: 'Mock search result for demonstration' },
        { title: `Another relevant result`, url: 'https://example.com/2', content: 'More information about the topic' },
      ],
      answer: `This is a mock search result for "${query}". Configure TAVILY_API_KEY to enable real searches.`,
    };
  }
  
  try {
    const response = await fetch('https://api.tavily.com/search', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        api_key: TAVILY_API_KEY,
        query,
        max_results: maxResults,
      }),
    });
    
    const data = await response.json();
    return {
      success: true,
      results: data.results || [],
      answer: data.answer,
    };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}

// Twitter/X Web Intent
async function postTweet(content: string) {
  const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(content.substring(0, 280))}`;
  return {
    success: true,
    message: 'Tweet URL generated',
    url: tweetUrl,
    content: content.substring(0, 280),
  };
}

// GitHub API
async function createGitHubIssue(owner: string, repo: string, title: string, body: string) {
  const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
  
  if (!GITHUB_TOKEN) {
    return { success: false, error: 'GitHub token not configured. Set GITHUB_TOKEN env var.' };
  }
  
  try {
    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/issues`, {
      method: 'POST',
      headers: {
        'Authorization': `token ${GITHUB_TOKEN}`,
        'Content-Type': 'application/json',
        'Accept': 'application/vnd.github.v3+json',
      },
      body: JSON.stringify({ title, body }),
    });
    
    const data = await response.json();
    
    if (response.ok) {
      return {
        success: true,
        issueNumber: data.number,
        url: data.html_url,
        title: data.title,
      };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}

// OpenAI API (content generation)
async function generateContent(prompt: string, maxTokens = 500) {
  const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
  
  // Mock mode when no API key
  if (!OPENAI_API_KEY) {
    const topic = prompt.replace(/Write a compelling.*about:|Write a professional.*about:/gi, '').trim();
    return {
      success: true,
      mock: true,
      content: `# ${topic}

This is a **mock blog post** generated because no OpenAI API key is configured.

## Introduction
Lorem ipsum dolor sit amet, consectetur adipiscing elit. In a real deployment, this would be AI-generated content.

## Key Points
- Point one about ${topic}
- Point two about ${topic}  
- Point three about ${topic}

## Conclusion
To enable real AI-generated content, set the OPENAI_API_KEY environment variable.

---
*Generated by Neo's Agent Task System*`,
    };
  }
  
  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: maxTokens,
      }),
    });
    
    const data = await response.json();
    
    if (response.ok && data.choices?.[0]?.message?.content) {
      return {
        success: true,
        content: data.choices[0].message.content,
        usage: data.usage,
      };
    } else {
      return { success: false, error: data.error?.message || 'Failed to generate content' };
    }
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}

// Execute agent task based on agent type
async function executeAgentTask(agentId: string, task: {
  title: string;
  description: string;
  metadata?: Record<string, any>;
}) {
  console.log(`[Executor] ${agentId} processing: ${task.title}`);
  
  switch (agentId) {
    // === RESEARCH AGENTS ===
    case 'scout':
    case 'radar':
    case 'compass':
    case 'trends': {
      const query = task.metadata?.query || task.description || task.title;
      return await searchWeb(query);
    }
    
    // === CONTENT AGENTS ===
    case 'ink': {
      const blogPrompt = `Write a compelling, well-structured blog post about: ${task.title}. \n\nDescription: ${task.description}\n\nInclude an engaging introduction, main points with explanations, and a conclusion.`;
      return await generateContent(blogPrompt, 1500);
    }
    
    case 'blaze': {
      const tweetContent = task.metadata?.content || task.description || task.title;
      return await postTweet(tweetContent);
    }
    
    case 'draft': {
      const emailPrompt = `Write a professional, engaging email about: ${task.title}. ${task.description}`;
      return await generateContent(emailPrompt, 500);
    }
    
    // === DEV AGENTS ===
    case 'byte':
    case 'server': {
      const issueTitle = task.title;
      const issueBody = task.description + '\n\n' + JSON.stringify(task.metadata || {}, null, 2);
      const repo = task.metadata?.repo || 'g8rmyvkxpy-png/Mission-Control';
      const [owner, repoName] = repo.split('/');
      return await createGitHubIssue(owner, repoName, issueTitle, issueBody);
    }
    
    // === SALES AGENTS ===
    case 'atlas':
    case 'pulse':
    case 'hunter':
    case 'phoenix': {
      const leadQuery = task.metadata?.domain || task.description || task.title;
      return await searchWeb(`companies relevant to: ${leadQuery}`);
    }
    
    // === RETENTION AGENTS ===
    case 'bond':
    case 'mend':
    case 'grow': {
      const customerQuery = task.metadata?.customer || task.description;
      return await searchWeb(`customer information: ${customerQuery}`);
    }
    
    default:
      return { success: false, error: `No handler for agent: ${agentId}` };
  }
}

// === TASK PROCESSOR ===

// Process pending tasks (runs every 10 seconds)
let processorInterval: NodeJS.Timeout | null = null;

function startProcessor() {
  if (processorInterval) return;
  
  processorInterval = setInterval(async () => {
    await processTasks();
  }, 10000);
  
  // Run immediately
  processTasks();
}

async function processTasks() {
  const pendingTasks = tasks.filter(t => t.status === 'pending');
  
  if (pendingTasks.length === 0) return;
  
  console.log(`[TaskProcessor] Processing ${pendingTasks.length} tasks`);
  
  for (const task of pendingTasks) {
    if (!task.assignedTo) {
      task.status = 'failed';
      task.error = 'No agent assigned';
      task.completedAt = Date.now();
      task.updatedAt = Date.now();
      console.log(`[TaskProcessor] Task ${task.id} failed: no agent`);
      continue;
    }
    
    task.status = 'processing';
    task.updatedAt = Date.now();
    console.log(`[TaskProcessor] Running ${task.assignedTo} on: ${task.title}`);
    
    try {
      const result: { success: boolean; error?: string; [key: string]: any } = await executeAgentTask(task.assignedTo, {
        title: task.title,
        description: task.description,
        metadata: task.metadata,
      });
      
      if (result.success) {
        task.status = 'completed';
        task.result = result;
        console.log(`[TaskProcessor] ✓ Task ${task.id} done`);
      } else {
        task.status = 'failed';
        task.error = result.error || 'Unknown error';
        console.log(`[TaskProcessor] ✗ Task ${task.id}: ${task.error}`);
      }
    } catch (error: any) {
      task.status = 'failed';
      task.error = error.message;
      console.log(`[TaskProcessor] ✗ Task ${task.id} error: ${error.message}`);
    }
    
    task.completedAt = Date.now();
    task.updatedAt = Date.now();
  }
}

// Start processor
startProcessor();

// === QUEUE FUNCTIONS ===

function enqueueTask(task: Omit<Task, 'id' | 'status' | 'createdAt' | 'updatedAt'>): Task {
  const newTask: Task = {
    ...task,
    id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    status: 'pending',
    createdAt: Date.now(),
    updatedAt: Date.now(),
  };

  const insertIndex = tasks.findIndex(t => priorityOrder[t.priority] > priorityOrder[newTask.priority]);
  
  if (insertIndex === -1) {
    tasks.push(newTask);
  } else {
    tasks.splice(insertIndex, 0, newTask);
  }

  console.log(`[Queue] Task ${newTask.id} assigned to ${newTask.assignedTo || 'none'}`);

  return newTask;
}

// === API ROUTES ===

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const status = searchParams.get('status');
    const assignee = searchParams.get('assignee');
    
    let filteredTasks = [...tasks];
    
    if (status) filteredTasks = filteredTasks.filter(t => t.status === status);
    if (assignee) filteredTasks = filteredTasks.filter(t => t.assignedTo === assignee);
    
    const queueStatus = {
      pending: tasks.filter(t => t.status === 'pending').length,
      processing: tasks.filter(t => t.status === 'processing').length,
      completed: tasks.filter(t => t.status === 'completed').length,
      failed: tasks.filter(t => t.status === 'failed').length,
      total: tasks.length,
    };
    
    return NextResponse.json({
      tasks: filteredTasks,
      queueStatus,
      agents: AGENTS,
    });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { title, description, assignedTo, priority, metadata } = body;
    
    if (!title) {
      return NextResponse.json({ error: 'Title is required' }, { status: 400 });
    }
    
    const task = enqueueTask({
      title,
      description: description || '',
      assignedTo,
      priority: priority || 'medium',
      metadata,
    });
    
    return NextResponse.json({ success: true, task });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function PATCH(request: Request) {
  try {
    const body = await request.json();
    const { taskId, action } = body;
    
    if (!taskId || !action) {
      return NextResponse.json({ error: 'taskId and action required' }, { status: 400 });
    }
    
    const taskIndex = tasks.findIndex(t => t.id === taskId);
    if (taskIndex === -1) {
      return NextResponse.json({ success: false, error: 'Task not found' });
    }
    
    const task = tasks[taskIndex];
    let result = false;
    
    if (action === 'cancel' && task.status === 'pending') {
      task.status = 'failed';
      task.error = 'Cancelled';
      task.updatedAt = Date.now();
      result = true;
    } else if (action === 'retry' && task.status === 'failed') {
      task.status = 'pending';
      task.error = undefined;
      task.updatedAt = Date.now();
      result = true;
    }
    
    return NextResponse.json({ success: result });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function DELETE(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const clear = searchParams.get('clear');
    
    if (clear === 'history') {
      tasks = tasks.filter(t => t.status === 'pending' || t.status === 'processing');
      return NextResponse.json({ success: true });
    }
    
    return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
